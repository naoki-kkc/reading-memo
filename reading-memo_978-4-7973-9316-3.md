# 読書メモ@体系的に学ぶ安全なWebアプリケーションの作り方


## 1. Webアプリケーションの脆弱性とは

### 脆弱性 = 悪用できるバグ。
悪用とは以下のようなことを指す。
- 機密情報を許可なく/アクセス権なく閲覧する
- Webサイトを書き換える
- Webサイト閲覧者にウイルスを感染させる
- 異なるユーザーになりすまして処理を行う
- Webサイトのコンピュータ資源を無断で使用する
- Webサイトを利用不能にする

### 悪用されると…
悪用されると以下が発生しうる。
- 経済的損失
    - 利用者への補填/補償(及びその費用/配送費)
    - 停止による機会損失
    - 信用失墜による売り上げの低下
    - 被害を受けた取引先からの損害賠償請求
- 法的な要求
    - 個人情報保護法 第20条に「安全措置を講じる義務」が科されている
        - 具体的な内容は個人情報保護委員会が定める各種ガイドラインを参照
- 回復不可能なダメージ
    - 流出した個人情報
    - なりすましで毀損された名誉
    - クレジットカード流出によるユーザーの不安や苦痛
- 攻撃インフラへの加担
    - 改竄されたWebサイトからウイルス感染→ボットネットワークへ参加

### 脆弱性の原因

主な原因は以下の2つ。

- バグによるもの
    - クロスサイトスクリプティング
    - SQLインジェクション
- チェック機能の不足によるもの
    - ディレクトリトラバーサル

### バグではないけれど脆弱性になりうるもの

- 通信経路をHTTPSで暗号化していない
    - 通信内容が盗聴される可能性がある
    - 費用との兼ね合いで発注者側が決めるもの

## 2. 実習環境のセットアップ

ハマったこと

- ポート番号を一桁間違えて通信できなかった(正：58888、語：5888)

## 3. Webセキュリティの基礎

### HTTP

#### リクエストメッセージ

以下にHTTP通信時のリクエストメッセージ例を示す。

```
GET http://example.jp/31/31-001.php HTTP/1.1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:76.0) Gecko/20100101 Firefox/76.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: ja,en-US;q=0.7,en;q=0.3
Connection: keep-alive
Referer: https://example.jp/31/
Cookie: PHPSESSID=9bpnjpjia4tvgjo7d0uf31ktt7
Upgrade-Insecure-Requests: 1
Host: example.jp
```

上記からリクエストラインのみ取り出したものが以下。

```
GET http://example.jp/31/31-001.php HTTP/1.1

```

それぞれの内容は以下の通り。

|項目|内容|
|---|---|
|メソッド|GET|
|URL(URI)|http://example.jp/31/31-001.php|
|プロトコルバージョン|HTTP/1.1|

リクエストメッセージには以下が含まれることがある。

|項目|内容|詳細|
|---|---|---|
|Referer|リファラー|リンク元を示しているが、ツールによる改変やセキュリティソフトによる削除が可能。<br>秘密情報は含まないようにするべき。セッションIDを含んでいるとなりすましに悪用されることがある。|

#### レスポンスメッセージ

以下にHTTP通信時のレスポンスメッセージ例を示す。

```
HTTP/1.1 200 OK
Server: nginx/1.10.3
Date: Tue, 26 May 2020 06:20:58 GMT
Content-Type: text/html; charset=UTF-8
Content-Length: 20
Connection: keep-alive
X-UA-Compatible: IE=edge

<body>
15:20</body>
```

|項目|内容|
|---|---|
|ステータスライン|HTTP/1.1 200 OK|
|ヘッダ|Server: nginx/1.10.3<br>Date: Tue, 26 May 2020 06:20:58 GMT<br>Content-Type: text/html; charset=UTF-8<br>Content-Length: 20<br>Connection: keep-alive<br>X-UA-Compatible: IE=edge<br>|
|空行|ヘッダとボディの間は空行となる|
|ボディ|&lt;body&gt;15:20&lt;/body&gt;|

上記のステータスラインを分解したものが以下である。

|項目|内容|
|---|---|
|プロトコルバージョン|HTTP/1.1|
|ステータスコード|200|
|テキストフレーズ|OK|

主なステータスコードは以下である。
参考： [HTTP レスポンスステータスコード](https://developer.mozilla.org/ja/docs/Web/HTTP/Status)

|ステータスコード|内容|
|---|---|
|1xx|情報レスポンス|
|2xx|成功レスポンス|
|3xx|リダイレクト|
|4xx|クライアントエラー|
|5xx|サーバーサイドエラー|

上記のヘッダには以下が含まれる。

|項目|内容|
|---|---|
|Content-Length|ボディのバイト数|
|Content-Type|リソースの種類を示すMIMEタイプ|

主なMIMEタイプは以下である。

|MIMEタイプ|内容|
|---|---|
|text/plain|テキスト|
|text/html|HTML文書|
|text/css|CSS|
|application/xml|XML文書|
|application/pdf|PDF文書|
|application/x-www-form-urlencoded|URLエンコード(指定がない場合)|
|image/jpeg|JPEG画像|
|image/png|PNG画像|

#### GETとPOSTの使い分け

[RFC7231](https://tools.ietf.org/html/rfc7231)に使い分けの注意が記載されている。

- GETは参照のみで副作用(CRUDでいうところのCUD)がない
- 秘密情報の送信はPOSTを用いる

また、GETには以下のような制限もある

- 送信するパラメータがURLに展開されるため、一部のブラウザではURLの上限を超える可能性がある
- 指定されたパラメータがRefererで外部に漏洩する
- 指定されたパラメータがアクセスログに残る
- 指定されたパラメータがブラウザのアドレスバーに表示され、覗かれる危険性がある

以上により、使い分けは以下となる。

|用途|メソッド|
|---|---|
|データを取得するリクエスト|GET|
|データ追加/更新/削除など副作用があるリクエスト|POST|
|秘密情報を送信する|POST|
|送信するデータ総量が大きい|POST|

### hiddenパラメータ

HTTPはステートレスであるが、現在の状態を表現するために何らかのデータが必要な場合がある。
このデータを表現するため、画面上不可視だがhtmlソースに記載されているデータにhiddenデータがある。
hiddenデータには以下の特徴がある。

- 利用者からの書き換えには弱いが、第三者からの書き換えには堅牢である
- 情報漏洩には堅牢である
- 認証・認可前等、セッションに保存できない状況で使用する

### Cookie

Cookieは少量のデータをブラウザ側で覚えておける仕組みである。
ただし、以下の理由からアプリケーションのデータを保持する目的で使用されることはあまりない。

- 保持できる値の個数や長さには制限がある
- 利用者側で参照/変更が可能なため、秘密情報の格納には向かない

それでもアプリケーションのデータを格納する場合、以下が想定される。

- 整理番号としてのセッションIDの格納

生成時に指定する属性は以下の通りである。

|属性|内容|
|---|---|
|Domain|ブラウザが値を送信するサーバーのドメイン(指定がない場合は生成したサーバーのみ)<br>複数のサーバーに送信する必要がない場合、指定しないことが推奨される|
|Path|ブラウザが値を送信するURL|
|Expires|有効期限(指定がない場合ブラウザの終了時)|
|Secure|HTTPSで通信している場合のみ送信(指定がない場合全ての通信で送信)|
|HttpOnly|JavaScriptからアクセス不可。設定することによる悪影響は通常無い|

### セッションID

セッションIDには以下の要件が求められる。

- 要件1：第三者がセッションIDを推測できないこと
- 要件2：第三者からセッションIDを強制されないこと
- 要件3：第三者にセッションIDが漏洩しないこと

セッションIDを生成する際、以下に留意する必要がある。

- 暗号論的擬似乱数生成器を用いて生成する
    - 電子政府推奨暗号リストに掲載されているものから選定するとよい
- Webアプリケーション開発ツールが提供するセッション管理機構を利用する
    - メジャーなツールであれば世界中の研究者が調査していて改善されているはず
    - セッション管理機構を自作し、バグが入り込むことはよくある

セッションIDの漏洩は以下で発生する。

- クッキー発行時の不備
- 通信経路上で盗聴される
- アプリケーションの脆弱性で漏洩
- プラットフォームの脆弱性により漏洩
- URLに保持していたためRefererヘッダから漏洩

### 能動的攻撃と受動的攻撃

Webアプリケーションに対する攻撃は以下の2種類に分類される。

|種類|内容|攻撃例|
|---|---|---|
|能動的攻撃|攻撃者が直接攻撃すること|SQLインジェクション|
|受動的攻撃|攻撃者が利用者向けに罠を仕掛け、罠を閲覧した利用者から攻撃させること|XSS|

ブラウザは以下のような機能を制限したサンドボックスを設け、被害が及ばないようにしている。

- ローカルへのアクセス禁止
- 資源の利用禁止
- アクセス制限等
    - 同一オリジンポリシー

### 同一オリジンポリシー(same origin policy)

クライアントスクリプトからサイトを跨ったアクセスを禁止する制限。
これにより意図しないホストへのアクセスというセキュリティ上の問題を防いでいる。
以下を元に同一オリジンの判定が行われる。

- FQDNが一致
- スキームが一致
- ポート番号が一致

同一オリジンポリシーの適用は以下の通りである。

|種類|適用|
|---|---|
|script|○|
|iframe/frame|○ (内部で実行されるJavaScript)|
|img|-|
|css|-|
|form|-|
|XMLHttpRequest|○(CORSによって回避可能)|

### CORS(Cross-Origin Resource Sharing)

JavaScriptの活用が進むにつれて同一オリジンポリシーの制限を超えるニーズが増えた。
このため、XMLHttpRequestでサイトを超えてやりとりする仕様としてCORSが策定された。

#### シンプルなリクエスト

シンプルなリクエストでは送信先の許可なしで異なるオリジンにHTTPリクエストを送ることが可能である。
シンプルなリクエストに該当するのは以下の場合である。

|項目|内容|
|---|---|
|メソッド|以下のいずれか<br>・GET<br>・HEAD<br>・POST|
|setRequestHeader|以下に限る<br>・Accept<br>・Accept-Language<br>・Content-Language<br>・Content-Type|
|Content-Type|以下のいずれか<br>・application/x-www-form-urlencoded<br>・multipart/form-data<br>・text/plain|

クロスオリジンから読み出し許可をするための仕組みとしてAccess-Control-Allow-Originがある。
情報の提供元がHTTPレスポンスヘッダに設定して送信することで、異なるオリジンからも読み出しが可能となる。

#### プリフライトリクエスト(pre-flight request)

クロスオリジンでシンプルなリクエスト以外のHTTPリクエストを送信する場合、本来のリクエスト前にプリフライトリクエストを送信する。
要求の種類、リクエスト、レスポンスをまとめると以下になる。

|要求|リクエスト|レスポンス|
|---|---|---|
|メソッドの許可|Access-Control-Request-Method|Access-Control-Allow-Method|
|ヘッダの許可|Access-Control-Request-Headers|Access-Control-Allow-Headers|
|オリジンの許可|Origin|Access-Control-Allow-Origin|

#### 認証情報を含むリクエスト

デフォルトでは含まれない認証情報を送信するには`withCredentials`を`true`にする必要がある。
上記が設定されている場合、レスポンスヘッダで`Access-Control-Allow-Credentials:true`を返す。

## 4. Webアプリケーションの機能別に見るセキュリティバグ

### 脆弱性はどこで発生するのか

Webアプリケーションの脆弱性は1箇所で発生するわけでは無い。
処理内容に応じて脆弱性は異なる。

|処理|発生する脆弱性|
|---|---|
|ブラウザで表示|XSS<br>HTTPヘッダインジェクション|
|RDBへのアクセス|SQLインジェクション|
|シェルで外部コマンドを実行|OSコマンドインジェクション|
|メール送信|メールヘッダインジェクション|
|ファイル操作|ディレクトリトラバーサル|
|重量な処理|CSRF|
|認証・認可|セッションID固定化<br>認可不備|

### インジェクション系攻撃の共通点

「hogefugaインジェクション」は当該処理の文法で特定の挙動をする文字列(終端文字等)を混入させ、本来の挙動を変化させることで引き起こされる。

|脆弱性|インターフェイス|手口
|---|---|---|
|XSS|HTML|JavaScriptの混入|
|HTTPヘッダインジェクション|HTTP|HTTPレスポンスヘッダの混入|
|SQLインジェクション|SQL|SQL文の注入|
|OSコマンドインジェクション|シェルスクリプト|コマンドの注入|
|メールヘッダインジェクション|sendmailコマンド|メールヘッダ/本文 の 注入/改変|

### Webアプリケーションの入力

Webアプリケーションに何らかの入力を行う場合、入力値に対して以下の処理を行う必要がある。

- 文字エンコーディングの妥当性チェック
    - Webアプリケーションは特定の文字エンコーディングであることを前提としている
- (必要であれば)文字エンコーディングの変換
- 入力値の妥当性チェック
    - 入力の間違いを早期に発見して再入力を促し、ユーザビデリティが向上する
    - 誤った入力によるデータの不整合を防止し、システムの信頼性が向上する

入力値をチェックするのは**セキュリティのためではない**が、結果的にセキュリティ向上に寄与することがある。
以下のような効果もあるが、あくまで保険的対策と捉えるべきである。

- 英数字のみを許可していたため、擬似的なSQLインジェクション対策になった
- 入力段階で制御文字を弾いているため、PHPのバイナリセーフでは無い関数を使っても問題にならない
- 関数の処理に文字エンコーディングの指定がないが、入力段階で不正な文字エンコーディングをチェックしているので実害がない

入力値の検証内諭はアプリケーションの仕様に依存する。
「電話番号なら数字のみ」「ユーザーIDなら英数字のみ」のようなアプリケーションの仕様があるのであれば、それに基づいて検証仕様が決定される。


全てのパラメータにおいて、**最大文字数を仕様として定義すべき**である。
DBに格納するデータであればテーブル仕様で決められているはずだし、上限がない場合でも動作保証するための最大文字数を仕様として決めるべき。
文字数が少ない場合、攻撃に必要な文字数を下回ることで保険的対策となる場合もある。


数値項目については以下の内容で検証を行う。
- 文字種チェック
- 文字数チェック
- 型変換チェック(文字列->数値)
- 範囲チェック(最小値〜最大値)

### 正規表現

文字種チェック、文字数チェックについては正規表現が有効である。

### クロスサイトスクリプティング(Cross-Site Scripting, XSS)

#### 概要

Webアプリケーションに外部からの入力を表示する箇所が存在すると、XSS脆弱性が生じる。
攻撃者の用意したスクリプトがサイト利用者のブラウザ上で動作し、以下のような被害が発生する。

- Cookie値が盗まれ、攻撃者がサイト利用者になりすます
- 攻撃者がサイト利用者の権限でアプリケーションの機能を悪用する
- 偽の入力フォームが表示され、フィッシングによる利用者が個人情報を盗まれる

通常、外部からの入力を表示する箇所が複数存在するが、1箇所でもXSS脆弱性があると利用者が被害を受ける可能性がある。
対策が必要な箇所が多い一方、運営者が影響を軽視し、対応が疎かになる傾向にある。

- Cookieの盗み出し
    - JavaScriptを実行し、`document.cookie`でCookieの内容を盗み出す
- JavaScriptによる攻撃
    - 最近のAjaxの流行により用意されている様々なAPIは攻撃に悪用することも可能
- 画面の書き換え
    - `form`や`style`を使用して本来の入力フォームを書き換え、有効なデータを入力するフィールドを追加し、罠サイトへ入力値を飛ばす

#### 反射型XSSと持続型XSS

攻撃用JavaScriptがどこに存在するかによって、XSS攻撃は以下のように分類できる。

|種類|JavaScriptの場所|
|---|---|
|反射型XSS(reflected XSS)|攻撃対象サイトとは別のサイト|
|持続型XSS(stored XSS / persistent XSS)|攻撃対象サイトのデータベース|

反射型XSSの多くは入力値をそのまま表示するページで発生し、持続型XSSはWebメールやSNSなどが典型的なターゲットになる。

#### 原因と対策

HTML生成の際にメタ文字をエスケープしておらず、開発者の意図しないHTMLやJavaScriptが注入/変形されることでXSSが発生する。
以下のメタ文字をエスケープすることがXSS脆弱性対策の基本である。

- 要素は「&lt;」と「&amp;」
- 属性値は「&lt;」と「&amp;」と「"」

保険的対策として以下が存在する。

- X-XSS-Protectionレスポンスヘッダを利用し、XSSフィルタ設定を有効にする
    - すべてのHTTPレスポンスで出力することが推奨される
- 入力値検証
    - 入力形式が固定の場合有効。自由入力形式では防げない。
- CookieにHttpOnly属性付与してJavaScriptで読み出せないようにする

#### tips

- クロスサイトトレーシング(Cross-site Tracing、XST)
    - 2006年以前の古いブラウザのみ成立する攻撃
    - 脆弱性として検出されることがあるが、今は対策が終わっているので対策不要





### SQLインジェクション

#### 概要

Webアプリケーションに外部からの入力をSQLの呼び出しに使用した際に発生する脆弱性。

- DB内の情報が外部から盗まれる/書き換えられる
- 認証を回避
- DBサーバー上のファイル読み出し/書き込み/プログラム実行

影響が非常に大きい脆弱性のため、**絶対に混入しない**プログラミングが求められる。

- DBのエラーメッセージ経由の情報漏洩
    - Webアプリケーションに表示するエラーに、任意の情報が表示される
- `UNION SELECT`を用いた攻撃
    - 成立すると一度の攻撃で大量の情報が漏洩する
- 認証回避
    - `OR`で`true`になるSQLを接続すると、パスワードを知らなくてもログインできてしまう
- データ改竄
    - SQLに`UPDATE`が追加され、データが書き換わる
- その他の攻撃
    - データベースエンジンによってはOSコマンドの実行、ファイル読み書き、HTTPリクエストによる他サーバーへの攻撃が可能になる

#### 原因と対策

SQL標準規格で有効な文字列リテラルのエスケープ抜けでSQLインジェクション脆弱性が生じる。
対策として以下がある。

- プレースホルダを利用する
    - SQL中に`?`でプレースホルダを設定し、パラメータをバインドする
- SQL文を組み立てる際にリテラルを正しく構成してSQL文が構築されるようにする
    - 完全な対応が難しいので**選択するべきではない**
- 複文の実行を禁止する
    - セミコロン区切りで複数のSQLが実行されなくなる
    - 設定のみで対応ができるが、過度な期待は禁物

#### 静的プレースホルダと動的プレースホルダ

静的プレースホルダと動的プレースホルダでは値をバインドする場所が異なる。

|種類|値をバインドする場所|備考|
|---|---|---|
|静的プレースホルダ|データベースエンジン|プレースホルダの状態でSQLがコンパイルされるので、後からSQL文が変更されることが原理的にありえない|
|動的プレースホルダ|アプリケーションのライブラリ内|バインド時にリテラルが処理されるので、処理系にバグがないかぎり脆弱性が生まれない|

どちらもSQLインジェクションは発生しないが、原理的にありえない静的プレースホルダの方が優れている。
**可能であれば静的プレースホルダ**を採用すべき。



### クロスサイトリクエストフォージェリ(CSRF)

#### 概要

重要な処理を行う前に意図したリクエストか確認が抜けており、罠サイトを閲覧しただけで利用者のブラウザから実行される脆弱性。
JavaScriptで呼び出されるWeb APIでも起こりうる。

- 利用者アカウントによる物品の購入/フォームへの書き込み/登録情報の変更
- 利用者アカウントの退会処理

処理を実行させることに特化しており、攻撃者が画面を見ることができないため、個人情報を盗むようなことはできない。
(ただしCSRFでパスワード変更→変更したパスワードで不正にログイン、と段階を踏めば個人情報が盗まれる)

#### XSSとCSRFの違い

CSRFとXSS(reflected XSS)は攻撃方法が似ているため、混同されることがある。
以下の1〜3まではほぼ同一であるが、3で攻撃が成功するのがCSRF、5で攻撃が成功するのがXSSである。

1. 利用者が罠サイトを閲覧する
2. 仕掛けのあるHTMLがレスポンスとして利用者に返る
3. 攻撃用のリクエストを攻撃先のWebアプリケーションに送る(CSRF)
4. 仕掛けを含むHTMLがレスポンスとして利用者に返る
5. 利用者のブラウザ上で仕掛けが発動し、攻撃を行う(XSS)

ブラウザ上でJavaScriptが動作しているという点でXSSの方が攻撃にバリエーションがある。
しかし、CSRFは以下の点で注意が必要である。

- 脆弱性対策を設計段階から盛り込む必要がある
- XSSに比べて認知度が低く、対策が抜けやすい/進んでいない

#### 確認画面を使った防御

入力から実行まで、確認画面を挟むことによってCSRFの攻撃が成功しないと**誤解されている**。
確認画面を挟んだ際の画面遷移の例を以下に示す。

1. 入力画面で入力
2. 確認画面で表示
3. 実行画面で実行

2から3へhiddenパラメータで入力値を受け渡している場合、hiddenに任意の値を格納したリクエストを送ることで突破することが可能である。
2から3へセッション変数で入力値を受け渡している場合でも、iframe内で

1. セッション変数に書き込むPOST
2. n秒後に遅れて実行画面を呼び出す

という2段階で突牌することが可能である。
(さらに多段にしたところでiframeを増やせば突破されてしまう)

#### 原因と対策

Webには以下の性質がある。

- formのactionにはどのドメインのURLでも指定可能
    - 罠サイトからでも送信可能
- Cookieに保管されたセッションIDは対象サイトへ自動送信される
    - 罠サイト経由のリクエストでも送信されてしまうので認証済みとして扱われる
    - Cookie以外でも自動送信されるパラメータを使っていれば同じこと

以上により、CSRFの対策として以下が必要である。

- CSRF対策の必要なページを区別
    - **勝手に実行されると困るページ**(物品購入、個人情報変更等)のみ対策が必要
        - 設計段階から必要なページを明確にして、対策を埋め込む
- 意図したリクエストであることを確認
    - 第三者に予測不可能なトークンの埋め込み
        - 最も一般的。ありとあらゆる場面で利用を推奨
        - 多段の場合、実行ページの直前に埋め込む
        - フレームワークに機能があればそれを、なければ暗号論的擬似乱数発生器で生成する
    - パスワード再入力
        - なりすまし対策が必要なページ(物品購入、パスワード変更)には特に有効
        - ログアウトのような本人確認が不要な処理に入れると煩雑なWebアプリケーションになってしまう
    - Refererのチェック
        - ファイアウォールやブラウザのアドオンでRefererを抑制している場合には使えない欠点がある
        - 利用者の環境が限定できており、既存アプリケーションの脆弱性対策に限って利用する

保険的対策として以下がある。

- 登録済みメールアドレスにメール通知
    - CSRFは成立するが、利用者が早期に気付けるため、被害を最小限に留められる
    - メールは平文なので、機密情報は含めない

### クリックジャッキング

#### 概要

iframeとCSSで攻撃対象と罠サイトを重ね合わせ、利用者が意図せず攻撃対象サイトをクリックするよう仕向ける攻撃手法。
CSSのz-index等を使用し、本来の要素の上に別要素を表示することで、利用者を別ボタンに誘導している。
利用者に処理を実行させることはできるが、結果を攻撃者が知ることはできない。(この点においてCSRFと似ている)

#### 原因と対策

HTMLの仕様を悪用した攻撃のため、バグを修正すれば防げる脆弱性ではない。
対策にはブラウザ側の支援が必要になる。

- frame/iframeの挙動を制限するX-Frame-Optionレスポンスヘッダを使用する
    - アプリケーションでframe/iframeを使用している場合は`SAMEORIGIN`を、していなければ`DENY`を指定する
    - 実行ページの直前に必要だが、全てのページで出力しても問題ないのでhttpサーバ側で出力すると良い

保険的対策として以下がある。

- 登録済みメールアドレスにメール通知
    - 利用者が早期に気付けるため、被害を最小限に留められる

### セッションハイジャック

#### 概要
Webアプリケーションには認証結果や現在の状態を記憶する手段として、セッション管理機構がある。
セッションと利用者を結びつけるセッションIDが第三者に知られて悪用された場合、なりすましが可能となる。
これをセッションハイジャックと呼ぶ。


セッションハイジャックが成立すると、以下のような被害がありうる。

- 利用者の個人情報やメールの閲覧
- 利用者の持つ権限で処理を実行


セッションIDを知る手段は以下に分類される。

- セッションIDの推測
    - 連番、日時やユーザーIDを元に生成
    - OSSでセッションIDの生成ロジックが公開されている
- セッションIDの盗み出し
    - Cookieの属性不備
    - ネットワーク上で盗聴
    - XSSによる流出
    - ブラウザ/プラットフォームの脆弱性
    - URLに保持しているためRefererから
- セッションIDの強制
    - 攻撃者がセッションIDをブラウザに固定化すると、攻撃者が「知っている」状態となる
        - セッションIDの固定化攻撃(Session Fixation Attack)

上記の通り原因が多様であり、個別に対応していく必要がある。

#### 推測可能なセッションID

セッションIDに推測可能な生成規則が存在すると、セッションIDの推測が容易になり、悪用される可能性が高まる。
安易にセッション管理機構を自作せず、実績のある言語/ミドルウェアが提供するセッション管理機構を用いることで回避できる。

脆弱性のあるセッション管理機構では以下を元に生成していることが多い。
また、これらに加えてエンコード処理やハッシュ値が利用されることもある。
- ユーザーID
- メールアドレス
- リモートIPアドレス
- 日時(UNIX日時/年月日時分秒文字列)
- 乱数

攻撃者は推測したセッションIDでなりすましを試行する。
攻撃が成功すればセッションが有効となるため、以降はなりすましが可能である。

#### URL埋め込みセッションID

セッションIDをURLに埋め込むと、Refererに残るセッションIDが流出し、悪用される可能性がある。
これを防ぐため、URL埋め込みセッションIDを禁止する設定やプログラミングが求められる。
2000年前後に「Cookie有害論」が起こり、URL埋め込み方式が主流だったが、現在ではCookieに保存する方が安全である。

#### セッションIDの強制

PHPやASP.NETには未知のセッションIDを受け入れるセッションアダプションという性質がある。
このため、URLにセッションID文字列を指定すると、その文字列がセッションIDとして扱われ、固定化されてしまう。
また、セッションアダプションがない場合でも、有効なセッションIDを取得後、このセッションIDを強制するよう罠サイトを設定することで、固定化が可能である。

セッションIDをCookieにだけ保存している場合でも、ブラウザやWebアプリケーションの他の脆弱性を用いることで固定化が可能である。
また、通信経路上に攻撃者がいる場合でもプロキシツールを用いて改変可能である。
(HTTPS通信していてもHTTP通信でCookieを設定することで、HTTPSでもそのCookieを使うことになる。この改変を防ぐ方法はない)

セッションIDの固定化が成功した場合、引っかかった利用者としてログインしている状態となるため、利用者が可能な情報の取得/操作が可能である。

セッションIDの固定化に対して、以下の対策が有効である。
- URLにセッションIDを埋め込まない
- クッキーモンスターバグのあるブラウザを使わない/使わせない
- クッキーモンスターバグの発生しやすいドメインを使わない
    - 都道府県型ドメイン
    - 地域型ドメイン
- 他の脆弱性(XSS/HTTPヘッダインジェクション/Cookie書き換え)の対策をする

上記の対策すべてを実行するには難しく、セッションIDが外部から固定化されるのを完全に防ぐ手立てはない。
よって、セッションIDの固定化攻撃は許容し、仮に攻撃されても防ぐようにすることが一般的である。

セッションIDの固定化攻撃を前提とした対策は以下である。

- 認証時にセッションIDを再生成する
    - 開発言語/ミドルウェアに再生成する機能があれば利用する
    - 強制的に書き換えるので、固定化が無意味になる
- トークンで対策する
    - 明示的にセッションIDを再生成できない場合はトークンで
    - 予測困難性が要求されるので、暗号論的擬似乱数生成器を利用する

#### 原因と対策

- セッション管理機構の自作
    - 主要な言語/ミドルウェア/フレームワークはセッション管理機構がある
        - メジャーであればあるほどセキュリティ研究者が指摘して改善している可能性が高い
    - 脆弱性のないセッションID生成プログラムの開発は技術的難易度が高い
- URL埋め込みの禁止
    - 現在はCookieに埋め込むのが一般的
- 認証成功時にセッションIDを再生成する
    - できなければトークンで対応

### オープンリダイレクト

#### 概要

URLでパラメータとして任意のURLを指定すると、リダイレクトできる機能を備えるものがある。
このリダイレクト機能のうち、任意のドメインにリダイレクトできる脆弱性をオープンリダイレクトと呼ぶ。
オープンリダイレクトが可能な場合、利用者は知らないうちに別ドメインのフィッシングサイトへ誘導されてしまう危険性がある。

#### 原因と対策

オープンリダイレクト脆弱性が生まれる原因は以下の通りである。

- リダイレクト先のURLを外部から指定可能
- リダイレクト先のドメイン名が未チェック

ただし、以下の2点が揃っていれば脆弱性ではない

- 外部のドメインに遷移するのは仕様である
- 外部のドメインに遷移するのが利用者にとって自明である

対策は以下の通りである。

- リダイレクト先を固定化する
    - 外部から指定できない、固定のURLに遷移する
- リダイレクト先をURL以外で指定可能とする
    - 指定可能な文字列とURLの対応を内部で保持する
- リダイレクト先のドメインを確認する
    - 任意のドメインへの遷移を防止する

### HTTPヘッダインジェクション

#### 概要

リダイレクトやCookie発行のような外部から取得したパラメータを元にHTTPレスポンスヘッダを生成する際に発生する脆弱性をHTTPヘッダインジェクションと呼ぶ。
パラメータを介した攻撃により、以下のいずれか、または両方が発生する。

- 任意のレスポンスヘッダの挿入
- レスポンスボディの偽造

上記が可能になると、以下のような影響がある。

- 任意のCookieの生成
- 任意のURLへリダイレクト
- 表示される内容の改変
- 任意のJavaScriptの実行(XSSと同様)

#### 原因と対策

HTTPヘッダインジェクションの原因は以下の通りである。

- 自作したHTTPヘッダ出力処理
    - 改行を適切に処理できないと、新たなヘッダが定義されてしまう
    - 複数同じヘッダ存在すると、一番後ろのヘッダが出力される
        - これによってヘッダの上書きが発生する

対策は以下の通りである。

- 外部からのパラメータをHTTPレスポンスヘッダに出力しない
    - 設計段階で出力しないことを検討する
    - リダイレクト先はURLでなく固定または対応する番号を受け取って置換する or セッション変数で受け渡す
- リダイレクトやCookie生成を専用APIに任せ、ヘッダに使用するパラメータの改行文字チェックを行う
    - HTTPやCookieの規格に沿って出力する専用APIを通すことで、考慮漏れを防げる
        - しかし完全に対策されていないものもあるのでこれだけでは足りない
    - URIの改行はエラーとする
    - Cookie値の改行はエンコードする

### Cookie出力にまつわる脆弱性

#### 概要

Cookieは扱い方によって脆弱性が生まれることがある。
大きく分けると以下の通りである。

- 利用すべきでない目的での使用
- 出力方法の不備

正しいCookieの役割は、以下の通りである。

- セッションIDを保管する
- データそのものは保管しない

Cookie出力時に発生する脆弱性は以下の通りである。
どちらも受動的攻撃の脆弱性である。

- HTTPヘッダインジェクション
- Cookieのセキュア属性不足

#### Cookieの不適切な利用

Cookieは利用者から書き換えが可能でる。
よって、書き換えられると困る情報をCookieに保存すると、脆弱性が生まれる原因となる。
また、脆弱性にならない場合でも**Cookieにデータを保存しないことが推奨される。**

Cookieとセッション変数の比較は以下の通りである。

|比較対象|Cookie|セッション|
|---|---|---|
|使いやすさ|APIで取得/設定|変数と同様に使える|
|値の代入|文字列に変換する必要がある|変数と同様に使える(ことが多い)|
|格納可能な情報量|厳しい制限がある|リソースが許す限り無制限|
|利用者による参照|容易(Devtool等で確認可能)|不可能|
|漏洩しやすさ|漏洩しやすい|漏洩しやすさを制御可能<br>(パスワード入力を必須とする実装で回避可能、<br>セッションタイムアウトで参照不可になる)|
|利用者による改変|容易|不可能|
|第三者による改変|Cookieを改変可能な脆弱性があれば容易|Cookieを改変可能な脆弱性があっても不可能|
|寿命の制御|容易|セッション限り|
|異なるサーバーとの制御|ドメインが同一であれば可能|基本的に不可能|

複数サーバーにログイン状態を示す方法としてCookieは有効であるが、保存されている情報はトークンであり、ID/パスワードを生で保存しているわけではない。
トークンと結び付いた認証状態をサーバー側で管理する。

「暗号化した情報を`hidden`で持つ」実装は、パディングオラクルのような攻撃手法で解読されることがある。
このため、`hidden`やCookieで**解読されて困る情報をクライアント側に持たせるべきではない**。

#### Cookieのセキュア属性不備

CookieのSecure属性が有効な場合、HTTPS通信でのみ送信される。
一方、Secure属性のついていないCookieはHTTP通信で平文で送信されるため、盗聴される可能性がある(=セッションIDが漏洩して、なりすまし被害へ)。

セキュア属性不備の原因は以下の通りである。

- 開発者がセキュア属性を知らない
- セキュア属性でアプリケーションが動作不良となる
    - HTTPS通信とHTTP通信が混在している場合

HTTPS通信とHTTP通信が混在しており、常時TLS化が難しい場合、セキュア属性のトークンを利用する。
トークンを利用する理由は以下の通りである。

- 認証成功時に1度だけ生成される
- HTTPSのページで生成される
- ブラウザからHTTPS通信の時のみ送信されるため、確実に暗号化される
- HTTPSのページを閲覧するために必須とすることができる

#### 原因と対策

- 利用すべきでない目的での使用
    - セッションIDはCookieへ、解読されて困る情報はセッションへ
- 出力方法の不備
    - Cookieのセキュア属性を有効にする
    - HTTP/HTTPS混在の環境はサイト全体のHTTPS化(常時TLS)を検討
        - 難しければ認証時にトークンをセキュア属性が有効なCookieに格納

### メール送信の問題

// TODO: あとでやる


### ファイルアクセスにまつわる問題

#### 概要

Webアプリケーションにはパラメータからサーバー上のファイル名を指定できるものがある。
パラメータの取り扱い方によっては、以下の脆弱性を含んでしまうことがある。

- ディレクトリトラバーサル
- ディレクトリリスティング
- OSコマンドインジェクション

#### ディレクトリトラバーサル

外部からサーバ上のファイル名を指定するパラメータを指定できるWebアプリケーションでは、パラメータに対するチェックが不十分な場合、以下のような被害が発生する。

- Webサーバー上のファイルの閲覧
    - 情報漏洩
- Webサーバー上のファイルへの操作
    - 内容の改竄
    - ファイルの削除
    - 罠サイトへ誘導する仕掛けの設置
    - 設定ファイルの編集/削除によるサーバー機能停止
    - 任意のスクリプトを実行

サーバー上のファイルにアクセスするにはファイル名(とファイルパス)を知っている必要があるが、「まずはスクリプトのソースファイルを開き、そこから指定されているファイル名を特定する」という手法がある。

設計段階からファイル名を直に指定させないことを心がけることが必要である。

#### ディレクトリリスティング

Webサーバーの公開ディレクトリに閲覧されると困るファイルを配置してしまうことがある。
公開ディレクトリのため、URLで指定すると内容を閲覧可能になる。
これにより、以下のような被害が発生する。

- 重要情報の漏洩

原因は以下の通りである。

- 公開ディレクトリにファイルが配置されている
- URLを知る手段がある
    - ディレクトリにアクセスした際に一覧が表示されてしまう
    - ファイル名が日付やユーザー名、連番の場合、類推しやすい
    - エラーメッセージにファイル名が出力されてしまう
- ファイルに対するアクセス制限がない
    - 検索エンジンのクローラが探索可能になっている

#### OSコマンドインジェクション

Webアプリケーション内部でシェル経由のOSコマンドを実行していたり、ライブラリ/フレームワークが内部的にシェルを用いている場合、意図しないOSコマンドが実行可能な場合がある。
この脆弱性をOSコマンドインジェクションと呼ぶ。

OSコマンドインジェクション脆弱性があると、外部の攻撃者から様々な攻撃を受けることがある。
場合によっては権限昇格で管理者権限を取得されるため、非常に危険である。

- Webサーバー内のファイル閲覧/改竄/削除
- 踏み台にして別サーバーへの攻撃
- 暗号通貨の採掘

OSコマンドインジェクションは明示的にシェルを使っている部分(PHPのsystem関数)ではもちろん、内部的に使っている部分(Perlのopen関数)でも発生しうる。
脆弱性が発生するケースは以下の通りである。

- シェル経由でOSコマンドを呼び出す際、メタ文字が正しくエスケープされていない
    - 「`;`」や「`&`」で区切ることにより、1行で複数のコマンドが実行可能
    - OSによって異なるため、正しいエスケープは困難
- シェル機能を呼び出す関数を使用している


内部でシェルを呼び出す関数の一例は以下である。
|言語|関数|
|---|---|
|PHP|system()<br>exec()<br>passthru()<br>proc_open()<br>popen()<br>shell_exec()|
|Perl|exec()<br>sysem()<br>open()<br>qx/.../<br>\`...\`|
|Ruby|exec()<br>system()<br>\`...\`|

#### 原因と対策

- ディレクトリトラバーサル
    - ファイル名を外部から指定させない
        - ファイル名は固定
        - ファイル名をセッションに保持
        - ファイル名を番号や文字列に対応させ、それをパラメータで指定する
    - ファイル名にディレクトリ名を含ませない
        - 想定外のディレクトリへ移動させない
        - ディレクトリを示す文字はOSごとに違うので、吸収できるライブラリを使用する
    - ファイル名は英数字のみ
        - 記号を排除することでディレクトリの指定が不可能になる
- ディレクトリリスティング
    - 公開ディレクトリに意図しないファイルを配置しない
        - 設計時にファイルの格納場所を定義する
        - 既存のWebサイトの場合、`httpd.conf`や`.htaccess`の設定で暫定的対策をする
    - 非公開ディレクトリが利用できるか確認する
        - 特にレンタルサーバーの場合
- OSコマンドインジェクション
    - OSコマンド呼び出しを使わないよう実装する
         - 設計時点で主要な機能の実装方法とOSコマンドの使用有無を検討する
            - 使わざるを得ない場合は外部から受け取ったパラメータを直接渡さない
    - シェル呼び出し機能のある関数を避ける
        - 言語によって(Perl等)はシェルを経由しない関数があるので、利用する
    - 外部から入力された文字列を直接OSコマンド/シェル呼び出し関数に渡さない
        - コマンドによっては特定のパラメータを使用するようなエイリアスがあるので、それを用いる
    - パラメータをエスケープする
        - 複雑なので自作せず、安全なエスケープをするライブラリ関数を使用する

OSコマンドインジェクションの保険的対策は以下の通りである。

- パラメータ検証
    - ファイル名に使用する文字種を限定する
        - OSコマンドインジェクションに使用する文字を無効化
- アプリケーションを起動するユーザーの権限を必要最小限にする
    - 攻撃者はバックドアをドキュメントルートにダウンロードするが、書き込み権限がなければ成功しない
- OSやミドルウェアのパッチ適用
    - OSやミドルウェアの脆弱性から攻撃させない

### ファイルアップロードにまつわる問題

Webアプリケーションの中にはアップロードする機能を備えたものがある。
このアップロード機能に対する攻撃は以下の通りである。

- DoS攻撃
- スクリプトをアップロードして、サーバー上で実行
- 細工されたファイルをダウンロードさせる
- 閲覧権限のないファイルをダウンロードする

#### DoS攻撃

アップロード機能に対して巨大なファイルや大量のファイルを送信することで、Webサイトに過大な負荷をかけることをDoS攻撃(Denial of Service Attack)と呼ぶ。
DoS攻撃を受けると、以下のような影響がある。

- 応答速度の低下
- サーバーの停止

#### スクリプトをアップロードして、サーバー上で実行

アップロードしたファイルが公開ディレクトリに保存される場合、当該ファイルを呼び出すことでスクリプトが実行されてしまう。
ファイルには任意の内容を格納できるため、OSコマンドインジェクション攻撃と同様の被害がありうる。
アップロードされるファイルの拡張子が`php`、`asp`、`aspx`、`jsp`といったサーバー側で実行可能なスクリプトの拡張子になっていることもある。

#### 細工されたファイルをダウンロードさせる

攻撃者がアップロードしたファイルを利用者がダウンロードした際、ブラウザや当該ファイルに関連づいたソフトの脆弱性からマルウェアのダウンロード等が発生する。
ダウンロードしたファイルが原因で利用者がマルウェアに感染した場合、アップローダの運営側にも責任が問われる可能性がある。

攻撃者HTMLやJavaScriptを仕込んだ画像ファイルをアップロードし、利用者がこれを開いた際、ブラウザがHTNLと誤認してしまうと、XSS攻撃が発生する。

#### 閲覧権限のないファイルをダウンロードする

特定の権限/認証が必要なファイルを閲覧権限がない他のユーザーもダウンロードできてしまう問題。
多くはファイル本体へのアクセス制限がなく、格納先URLを推測してダウンロードしている。

#### 原因と対策

- DoS攻撃
    - アップロードのファイル制限
        - PHPであれはphp.iniで設定可能
- スクリプトファイルのアップロード
    - アップロードされたファイルを公開ディレクトリにおかない
    - 拡張子をスクリプト以外に制限する
        - 必要なものだけ許可するホワイトリスト方式にするべき
- 細工されたファイルをダウンロードさせる
    - ファイルのコンテントタイプを正しく設定する
    - レスポンスヘッダ`X-Content-Type-Options: nosniff`を指定する
        - コンテントタイプから判断するようにブラウザへ伝える
    - ダウンロードの場合、レスポンスヘッダに`Content-Disposition: attachment`を指定する
        - ダウンロードすべきであることをブラウザへ伝える
    
### インクルードにまつわる問題

#### 概要

一部のスクリプト言語(例：PHP)には、ソースの一部を別ファイルから読み込む機能が存在する。
`include`等に外部からファイル名を指定している場合、攻撃者がアプリケーションの意図しないファイルを指定することで攻撃が成立することがある。
ファイルインクルード攻撃の影響は以下の通りである。

- サーバー内のファイルが閲覧されたことによる情報漏洩
- 任意のスクリプトが実行される事による影響
    - サイト改竄
    - 不正な機能実行
    - 攻撃時の踏み台

### 原因と対策

ファイルインクルード攻撃の原因は以下の通りである。

- インクルードする関数に指定するファイルパスが外部から指定可能
- ファイル名の妥当性チェックがなされていない

ファイルインクルード攻撃の対策は以下の通りである。

- インクルードするパス名に外部パラメータを含めない
    - 外部パラメータを含める場合は英数字に限定する

### 構造化データの読み込みにまつわる問題

// TODO: あとでやる

### 共有資源やキャッシュに関する問題

#### 概要

Webアプリケーションは複数の要求を同時に受け付ける。
これにより、共有資源やキャッシュの取り扱いに関する問題が発生することがある。

#### 競合状態

複数のプロセス/スレッドから同時に利用している変数、共有メモリ、ファイル、データベースのことを共有資源と呼ぶ。
これらの排他処理が不十分な場合、以下のような競合状態の脆弱性の影響が出る。

- 別人の情報が表示される別人問題
- データベースの不整合
- ファイル内容の破壊

#### キャッシュからの漏洩

処理の高速化や負荷軽減を目的として、キャッシュを利用する。
有用な技術であるが、過剰に働いてしまうと情報漏洩の原因となることがある。

レスポンスヘッダの`Cache-Control`の設定によっては、Webサーバー(Apacheやnginx)は自らが管理するキャッシュを返してしまうことがある。
アプリケーション側で適切なレスポンスヘッダを出力しているか、確認する必要がある。
`Cache-Control`のディレクティブは以下の通りである。

|デイレクティブ|意味|
|---|---|
|no-store|一切キャッシュをしない|
|no-cache|キャッシュの有効性を都度確認|
|private|一人用のキャッシュを許可する(ブラウザキャッシュは有効、サーバーキャッシュは無効)|
|public|全てのキャッシュを許可する|
|must-revalidate|使用前にキャッシュが陳腐化していないか確認する|
|max-age|リソースが陳腐化していないとする最長期間(単位は秒)|

また、Webサーバー側で制御が不適切であり、キャッシュすべきではないリソースをキャッシュしていたことが原因であることもある。
ネットワークの構成によっては以下がキャッシュをしていることもある。

- リバースプロキシ
- CDN(Content Delivery Network)
- ロードバランサ

上記の管理者が別に存在する場合、連携が必要である。

#### 原因と対策

共有資源やキャッシュに関する問題の原因と対策は以下である。

- 競合状態
    - 排他が不十分
        - 共有資源の利用を避ける
        - 共有資源に対する排他処理を適切に行う
- キャッシュからの漏洩
    - アプリケーションの制御不備
        - 適切なレスポンスヘッダの設定
    - キャッシュサーバーの設定不備
        - 設定内容の確認(デフォルトでは過剰にキャッシュされないはず)

キャッシュからの漏洩の保険的対策は以下である。

- URLに乱数値を設定する
    - URLごとにキャッシュするため、別リソースとして扱われる
        - キャッシュ自体はされるのでストレージの無駄遣いになる
        - URLを知られると閲覧されるリスクがある

保険的対策を実施する場合でも、そもそもの対策(レスポンスヘッッダの設定、設定内容の確認)は行うべきである。

### Web API実装における脆弱性

#### 概要

Webアプリケーションには処理結果を画面ではなくデータで返すWeb APIが多く用いられている。
JavaScriptやスマホアプリからの利用g会おうかしたことで、サーバー側の実装形態として定着している。
Web APIに生じやすい脆弱性は以下の通りである。

- JSONエスケープの不備
- JSON閲覧によるXSS
- JSONPコールバック関数名によるXSS
- Web APIのCSRF
- JSONハイジャック
- JSONPの不適切な利用
- CORSの検証不備

#### JSON

Web APIはデータの受け渡し形式としてXMLを利用していたが、近年ではJavaScriptのオブジェクトリテラル形式を発展させたJSON(JavaScript Object Notation)が利用されることが増えた。
JSONはeval関数でJavaScriptのデータ形式に変換していたが、危険性があるため専用の関数を通して変換するようになった。

JavaScriptでJSONとJavaScriptオブジェクトを相互変換するには以下を用いる。

|変換|関数|
|---|---|
|JavaScriptオブジェクト→JSON|JSON.stringify|
|JSON→JavaScriptオブジェクト|JSON.parse|

変換例を以下に示す。
```
let obj = {a: "hoge", b:"fuga", c:"foobar"};
let obj_json = JSON.stringify(obj)           //<- "{"a":"hoge","b":"fuga","c":"foobar"}"
JSON.parse(obj_json)                         //<- {a: "hoge", b: "fuga", c: "foobar"}
```

#### JSONP

JavaScriptのXMLHttpRequestには同一オリジンポリシーの制約があり、これを解決するためにCORSがある。
CORSが規定される以前に異なるオリジンからデータを取得するため考案された方法がJSONP(JSON with Padding)である。
script要素から外部のJavaScriptを実行してデータを取得し、関数呼び出しとして生成する。

#### JSONエスケープの不備

JSON文字列を生成する際、エスケープ処理に不備があるとJSONデータに意図しないJavaScriptが混入することがある。
以下のような処理をしている場合、不正なJavaScriptが実行されてしまう。

- デコードにeval関数を使用している
- JSONPのようにscriptでJSONを読み込む

#### JSON閲覧によるXSS

Web APIはXMLHttpRequestによるアクセスを想定しているが、ブラウザで閲覧することで攻撃が可能になることがある。
以下のような場合、本脆弱が発生する。

- MIMEタイプがJSONではない
    - `application/json`が指定されるべきであるが、`text/html`になっている
        - ブラウザはhtmlとして解釈しようとする

また、JSON内でエスケープ必須ではないがXSSを発生させうる文字をエスケープすることで本脆弱性を回避可能である。

#### JSONPコールバック関数名によるXSS

JSONPのJSONコールバック関数は名前やパラメータが外部から指定できるケースが多い。
外部から悪意あるパラメータが指定され、MIMEタイプが指定されておらず、ブラウザがhtmlとして解釈した場合、XSSが発生する。

```
// コールバックに「<script>alert(1)</script>」を指定した例
http://api.example.com/api/call.php?callback=%3Cscript%3Ealert(1)%3C/script%3E
// response => <script>alert(1)</script>({"data": "somestring"});
```

#### Web APIのCSRF

一般的な画面を持たないWeb APIでもCSRFは発生しうる。
主な原因は以下の通りである。

- GETリクエストによる攻撃
    - 重要な処理はPOSTで実装されるべきだが、GETで実装されていた場合に攻撃されることがある。
- HTMLフォームによる攻撃
    - フォームのPOST値でMIMEタイプのチェックをしていない場合、攻撃が可能
- クロスオリジン対応XMLHttpRequestによる攻撃(シンプルなリクエスト/プリフライトリクエストなし)
    - CORS対応のXMLHttpRequestは異なるオリジンからリクエストの送信が可能
- クロスオリジン対応XMLHttpRequestによる攻撃(プリフライトリクエストあり)
    - プリフライトリクエストの時点で拒絶され、攻撃に**至らないはず**
        - プリフライトリクエストの処理に不備があったため、CSRF攻撃のプリフライトリクエストをkyと擁してしまうケースは**ありうる**

#### JSONハイジャック

JSONはscript要素で受け取れない(受け取りたければJSONP)はずだが、受け取り方法が研究されている。
この受け取る方法をJSONハイジャックと呼ぶ。
(ブラウザの脆弱性と考えられるが、Webアプリ側でも他対策していた方が好ましい)

#### JSONPの不適切な利用

JSONPは同一オリジンポリシーのすり抜けのために考案されたため、使い方を謝ると脆弱性が生まれやすい。
(特別な理由がない限りCORS対応のAPIに移行することが望ましい)
JSONPにはCORSのようなアクセス制御の仕組みがないため、秘密情報の公開は避けるべきである、

JSONPはWebアプリケーションのオリジンで異なるオリジンのAPIをscript要素で呼び出して実行するため、API提供側に悪意がある場合、XSSと同等の被害が発生する。
XMLHttpRequestは任意のJavaScriptを実行することはない。
この点からも早期にJSONPからCORS対応APIに移行すべきである。


#### CORSの検証不備

CORSは素直に従う限り問題が起こることはないが、**手抜きによって**問題が発生することがある。
以下のような設定を行うと、CORSが正常に機能しない。

- オリジンとして`*`を設定する
    - `Access-Control-Allow-Origin: *`
    - 公開情報を扱いなら問題ないが、非公開情報では情報漏洩の危険性がある
        - 連携先が非常に多いような場合、オリジンは`*`とした上で他の方法で情報漏洩を防ぐ
- オリジンのチェックを意図的に緩和する
    - そのような意図のスクリプトが出回っている
        - CORSをちゃんと考えて実装する必要がある

#### セキュリティを強化するレスポンスヘッダ

以下のHTTPレスポンスヘッダは常に出力するだけで、ブラウザ側でセキュリティ機能を強化できる。

|レスポンスヘッダ|内容|
|---|---|
|`X-Frame-Options`|frame/iframeの内部に表示できなくなる|
|`X-Content-Type-Options: nosniff`|MIMEタイプの解釈が厳密になる|
|`X-XSS-Protection`|ユーザーによる設定を上書きしてブラウザのXSSフィルタを有効化する|
|`Content-Security-Policy: default-src 'self'`|スクリプト、画像、CSSの読み込みを自身のオリジンに限定する|
|`Strict-Transport-Security`(HSTS)|HTTPSの通信を強制する。HTTPアクセスでHTTPSにリダイレクトされる際に中間者攻撃によるダウングレード攻撃を防ぐ|

#### 原因と対策

- JSONエスケープの不備
    - 文字列生成時に適切なエスケープが行われていない
        - JSON生成を信頼できるライブラリで行う
    - eval関数でデコードしている/JSONPを使用している
        - `JSON.parse`などのAPIでデコードする
- JSON閲覧によるXSS
    - MIMEタイプが不正である
        - [必須]正しいMIMEタイプを設定
        - [強く推奨]レスポンスヘッダに`X-Content-Type-Option: nosniff`(MIMEタイプに従うよう示すマーカー)を指定
    - XSSの原因となる文字がエスケープされていない
        - 記号をUnicodeエスケープする
        - CORS対応の機能だけから呼び出せるようにする
- JSONPコールバック関数名によるXSS
    - 外部から指定されたコールバック関数名を検証していない
        - コールバック関数名の文字種と文字数を制限する
            - 英数字とアンダースコアのみに制限するのが現実的
    - MIMEタイプが不正である
        - `text/javascript`を指定する
- Web APIのCSRF
    - GETリクエストによる攻撃
        - POSTで実装する
    - HTMLフォームによる攻撃
        - トークンを使用する(基本的なCSRF対策)
        - CSRFトークン(セッションにトークンを保持)
            - 認証時にJSONで返すよう修正
            - **CORS対応しない**ことで他オリジンから参照不可
        - 二重送信Cookie
            - トークンをCookieとリクエストヘッダのパラメータで送信、サーバー側で検証する
                - 不一致だった場合はセキュリティ上問題なので記録する
                - 攻撃者がCookieを固定化し、パラメータを送信した場合は防げない
        - カスタムリクエストヘッダ
            - 動的にカスタムリクエストヘッダを付与するJavaScriptライブラリを使用し、サーバー側で存在チェックをする
    - クロスオリジン対応XMLHttpRequestによる攻撃(シンプルなリクエスト/プリフライトリクエストなし)
        - 対策はHTMLフォームによる攻撃と同一
    - クロスオリジン対応XMLHttpRequestによる攻撃(プリフライトリクエストあり)
        - 正しくプリフライトリクエストを処理する
- JSONハイジャック
    - (基本劇に)ブラウザの脆弱性
        - [強く推奨]レスポンスヘッダに`X-Content-Type-Option: nosniff`(MIMEタイプに従うよう示すマーカー)を指定
            - ブラウザでMIMEタイプを厳格にチェックし、JSONやCSVの読み込みを拒否する
        - [推奨]リクエストヘッダ`X-Requested-With: XMLHttpRequest`を確認
            - JavaScriptライブラリからXMLHttpRequestを呼び出すと自動的に付与される
            - script要素からWeb APIを呼び出しても付与できない
            - サーバー側でチェックし、存在すれば正規の呼び出しとみなす
- JSONPの不適切な利用
    - Webアプリケーションのオリジンで異なるオリジンのJavaScriptが実行される(XSS)
        - JSONPをやめ、CORS対応APIにシフトする
 - CORSの検証不備 
    - 不適切なオリジンの設定
        - **原則として**オリジンの確認を行う
        - 連携先が非常に多い場合、別の方法で情報漏洩を防ぐ
    - オリジンのチェックを意図的に緩和する
        - **そもそもそんなことをすべきではない**

### JavaScriptの問題

//TODO あとでやる

### 脆弱性まとめ

|脆弱性|発生箇所|影響範囲|種類|影響度|利用者の関与|対策|
|---|---|---|---|---|---|---|
|XSS|入力値からHTML/JavaScriptを生成している箇所|全体|利用者のブラウザ上でJavaScriptの実行<br>偽情報の表示|中〜大|必要<br>罠サイトの閲覧|属性値をダブルクォートで囲む<br>HTML文字列のエスケープ|
|SQLインジェクション|SQL呼び出ししている箇所|全体|情報漏洩<br>データ改竄<br>認証回避<br>プログラム実行<br>ファイルの参照/更新|大|不要|静的プレースホルダの利用|
|CSRF|以下の状態で重要な処理が行われている箇所<br>・Cookieのみでセッション管理が行われている<br>・HTTP認証、TLSクライアント証明書のみで利用者を識別|CSRF脆弱性のあるページのみ|利用者の権限で処理が行われる箇所|中〜大|必要<br>リンクのクリック<br>罠サイトの閲覧|実行前に正規のリクエストであるか確認する|
|クリックジャッキング|認証後、ポインティングデバイスで処理を実行できるページ|クリックジャッキング脆弱性のあるページのみ|利用者の権限で処理が行われる箇所|中〜大|必要<br>罠サイトを閲覧して罠ページ上をクリック|X-Frame-Optionヘッダを出力|

## 5. 代表的なセキュリティ機能

### 認証

#### ログイン機能

ユーザーIDとパスワードを照合し、一致するものがあれば認証されたと見做す機能。
通常DBに格納されたデータをSQLを用いて検索し、その結果を元に判断を行う。
ログイン機能に存在する脆弱性と対応する攻撃は以下の通りである。

- SQLインジェクション脆弱性
    - ログイン機能のバイパス
    - パスワードの入手
        - DBにパスワードを保存する際は、仮に漏れても問題ないように実装する
- 脆弱性なし
    - ブルートフォールス攻撃/辞書攻撃
        - 手当たり次第ログインを試行する手法
        - 検知して止める
    - ソーシャルエンジニアリング
        - 利用者を騙してパスワードを取得する
        - Webアプリ側でできることはない
    - フィッシング
        - 本物そっくりのサイトに誘導し、ID/パスワードを取得する
        - なりすまし対策で対応する

ログイン機能が破られると、攻撃者は利用者の権限で閲覧/処理ができるようになる。
パスワードまで知られていると重要な処理まで実行可能になるため、セッションハイジャックよりも影響が大きい。

#### パスワード認証を狙った攻撃への対策

ブルートフォース攻撃への対策はアカウントロックが有効である。
以下のように実装すると良い。

1. ユーザーIDごとにパスワードを間違った回数を数える
2. 間違った回数が上限値(10回程度)を超えた場合、アカウントをロックする(=ログイン不可)(※)
3. アカウントをロックした旨をメール等で利用者と管理者に通知する
4. 管理者が何らかの方法で本人確認した後、ログイン可能になる
5. ログインした場合、間違った回数をリセットする

※ロックされてから30分経過自動的に再有効化されてもよい(PCI DSS 3.2では30分)。30分の再有効化は攻撃者が100個のパスワードを試すのに4時間半以上かかるため、何らかの対策をうつことができる。

パスワード認証に対する攻撃のバリエーションは以下である。

|攻撃名|内容|防御手段|
|---|---|---|
|辞書攻撃|使用頻度の高いパスワード候補から順に試す方法。危険なパスワードを使っている利用者が多い場合、効率的に試行できる|アカウントロック|
|ジョーアカウント探索|パスワードにユーザーIDと同じ文字列を設定するアカウントが一定割合存在することに着目し、ユーザーIDとパスワードが同じアカウントを探索する|下表の対策|
|リバースブルートフォール攻撃|パスワードを固定し、ユーザーIDを変更しながらログインを試行する|下表の対策|
|パスワードスプレー攻撃|ID/パスワードを固定することなく、少数のパスワード候補をIDを変えながら試行する|下表の対策|
|パスワードリスト攻撃|利用者のパスワードがサイトごとに異ならないことに着目し、脆弱性のある別のサイトから漏洩したIDとパスワードの一覧を用いてログインを試行する|下表の対策|

単純なアカウントロックで対応できない場合の防御手段は以下の通りである。
いずれも脆弱性への対策として必須ではないため、安全性や予算から実施するか検討する。

|防御手段|内容|
|---|---|
|二段階認証|IDとパスワードによる検証が成功した後、追加の秘密情報を要求する方式。<br>例としてメールやSMSで送信されたりスマホアプリで生成される短い数字がある。<br>利便性を下げないため、ログインのたびに要求するのではなく、以下のような状況で要求するとよい。<br>・初回ログイン時(その後一定期間は一段階認証)<br>・通常とは異なる地域、時間帯、ブラウザでログインした時<br>・決済やパスワード変更といった重要な処理を行う時|
|積極的なパスワードチェック|パスワード登録時に以下のようなパスワードチェックを行う<br>・辞書によるありがちなパスワードのチェック<br>・ユーザーIDと同一のパスワードチェック|
|ログイン失敗率の監視|パスワード認証に対する攻撃が発生すると、ログイン失敗率が急激に上昇する。<br>これを検知し、原因調査の上、該当するIPアドレスの通信を遮断する。|

#### パスワードの保存方法

パスワードが漏洩すると、以下のような影響が懸念される。

- パスワードリスト攻撃への悪用
- 利用者の権限で実行可能な機能の悪用

SQLインジェクション等の脆弱性でデータベースの情報が漏洩しても、パスワードは転用不可能な形式で保護すべきである。
この形式として、パスワードを暗号学的ハッシュ関数に通したメッセージダイジェストによる保護が広く行われている。
(「透過的データ暗号化(Transparent Data Encryption / TDE)」と呼ばれるデータベースを暗号化する製品が存在するが、SQLインジェクションには無力なため、導入していれば生パスワードを保存して良い**わけではない**。)

ハッシュ関数にはハッシュ値から元データを得ることが難しい「一方向性」と異なる入力から得られるハッシュ値が衝突する確率が極めて低い「衝突耐性」が要求される。

ハッシュ関数が安全でも、パスワードは以下の方法で解析可能である。
いずれの攻撃もパスワードを20文字以上にすれば回避できると考えられるが、ユーザーに入力させるのは現実的ではない。

- オフラインブルートフォール攻撃
    - ハッシュ関数が生成するメッセージダイジェストをオフラインで探索する
    - 現実的な時間で探索が完了してしまうため、単純なMD5やSHA-1によるハッシュ値では保護しているとは言えない
- レインボーテーブル
    - あらかじめ生成しておいたパスワードとハッシュ値の総当たり表を用いて、パスワードを逆引きする
    - 単純なハッシュ値ではレインボーテーブルによって短時間で解読される
    - 10文字以下であればレインボーテーブルが対応済み
- ユーザーDBに辞書を生成する
    - 未知のハッシュ関数に対して、よく使われるパスワードのユーザーを新規登録すると、それに対応したハッシュがDB上に生成される
    - SQLインジェクション等でDBの内容を取得し、登録したユーザーのハッシュを確認する
    - 当該ハッシュと同一のハッシュの別ユーザーIDがあれば、ログインが可能

ハッシュ値から解析を困難にするための方法は以下の通りである。

- ソルト
    - パスワードに文字列を追加する
        - ある程度の長さの文字列とする
            - 「パスワード+ソルト」で最低でも20文字必要 
        - ユーザーごとに異なる文字列を追加する
            - ソルトが衝突することがあっても確率が低ければ問題ない
- ストレッチング
    - ハッシュ値の計算を複数回行う
    - ハッシュ値の計算が遅いハッシュ関数を用いる
        - BCrypt
        - PBKDF2
        - Argon2

以下のようなパスワード漏洩経路も存在する。

- バックアップメディアの盗難/持ち出し
- ハードディスクの盗難/持ち出し
- バージョン管理システムからの漏洩
- 内部オペレータによる持ち出し

#### 自動ログイン

Webアプリケーションによっては「自動ログイン」や「ログイン状態保持」といった機能が存在する。
XSS攻撃や受動的攻撃の被害にあいやすいため、従来は好ましくないと考えられていた。
しかし現在では以下のような状況から、自動ログインを許容しても良いとされている。

- ログイン状態が継続していることを前提としたサービス
- ログイン回数が増えることにより利用者が単純なパスワードをつけやすくなる

自動ログインの危険な実装例としてCookieにユーザー名やパスワードが設定されていることがあるが、XSS脆弱性があった場合、ログインに必要な情報が盗まれるため、被害が拡大する。
安全な自動ログインの実装として、以下がある。

- セッションの寿命を伸ばす
    - CookieのExpire属性を設定可能な場合、一番簡単に実装できる
        - セッションタイムアウトを1週間に伸ばす
        - セッションIDのCookieのExpires属性を1週間後に設定
    - セッションのライフタイム設定を1週間などに伸ばす    
        - セッションにタイムアウト時間とタイムアウト時刻を保持
        - 次回ページを表示した際にセッションタイムアウト時刻と現在時刻を比較することでセッションタイムアウトを実現
- トークンの使用
    - CookieのExpire属性を設定できない場合はこちら
    - 暗号論的擬似乱数生成器で発生させたトークンを1週間程度の適当なExpire属性とHttpOnly属性(HTTPSの場合はセキュア属性も)を付与したCookieに格納する
    - 生成したトークン、ユーザーID、有効期限をDBに格納して自動ログインを管理する
    - ログイン時にCookieの内容をDBと照合する。ログアウト時にDBの内容を消去する
- チケットの使用
    - 認証情報を外部に持ち出し可能にしたもの(WindowsのKerberos認証、ASP.NETのフォーム認証)
    - サーバに跨って認証情報を共有可能
    - 独自実装は避けて、SSO製品を購入するか、OpenID Connectなどのオープンな認証基盤を利用する

上記3方式のうち、トークンを使うのが最も好ましい。
理由は以下の通りである。

- 自動ログインを選択しない利用者に影響がない
- 複数端末でログインしている場合、一括でログアウトができる
- 管理者がログイン状態をキャンセルできる
- クライアント側に機密情報が渡らない

先述の通り、認証状態が続くためにXSSとCSRFのリスクが高まるが、重要な処理の前にパスワード入力を求めることが有効である。

#### ログインフォーム

ログインフォームには一般的に以下が必要である。

- パスワード入力欄はマスク表示
    - 入力したパスワードが表示されないようになる
    - ショルダーハックによる盗み見リスクを軽減する
- HTTPSを利用する
    - 暗号化されて送信されるため、盗聴されなくなる
    - フォームが改竄されて送信先が別サイトになる危険性を回避できる
    - 偽アクセスポイント経由で偽物サイトが表示される可能性を回避できる
        - ドメインが正しいかの判断は利用者が確認する

#### エラーメッセージの要件

IDが判明するとパスワードの探索が容易になるため、IDとパスワードはどちらが間違っているか表示すべきではないとされている。
しかし、近年のログインフォームではIDとパスワードを2段階で認証するものが増えている。
これはユーザーにとってログインが煩雑な手段であり、負担となっていることに起因している。
ログインが負担であればあるほど安易なパスワードをつける傾向にあるため、ログイン試行がやりやすくなるデメリットより、複雑なパスワードを設定させる意図があると考えられる。

#### ログアウト機能

確実にログアウトする方法は以下の通りである。

- ログアウトは副作用があるのでPOSTメソッドでリクエストする
- ログアウト処理でセッションを破棄する
- 必要な場合はCSRF対策をする(トークンチェック)


#### 原因と対策

- ログイン機能
    - セキュリティバグをなくす
        - SQLインジェクション
        - セッションIDの固定化
        - Cookieのセキュア属性
        - オープンリダイレクト
        - HTTPヘッダインジェクション
    - パスワードを予測困難にする
        - 「パスワードの組み合わせ総数 = 文字種の数^桁数」である
            - 桁数の上限が少ないと総数が減る
            - 「US-ASCII文字全て × 128桁以下」を提案している
            - パスワードからパスフレーズへ
        - パスワードポリシーのチェック
            - 桁数(n桁以上)
            - 文字種(英字/数字/記号を1文字以上)
            - ユーザーIDと同じパスワードの禁止
            - パスワード辞書に載っているありがちな単語の禁止
            - やりすぎると意味がない上、NISTが発行したガイドライン(SP800-63-3)では推奨しないとされている

### アカウント管理

#### ユーザー登録

ユーザー登録では秘密情報を含むことが多く、セキュリティ上の注意点が多くある。

- メールアドレスの受信確認
- ユーザーIDの重複防止
- ユーザーの自動登録への対処
- パスワードに関する注意

メールアドレスの受信確認には以下の2パターンがある。

- 登録後、入力されたメールアドレスにメールを送信し、本文中に記載されたトークン付きURLを押下してもらう
    - メリット：ユーザーの操作感は良い、メール受信に時間がかかっても問題ない
    - デメリット：実装が面倒、メールクライアントによってはURLが正しく動作しない
- 登録中、入力されたメールアドレスにメールを送信し、本文中に記載されたトークンを登録画面に入力してもらう
    - メリット：ユーザーの操作感は良い、メール受信に時間がかかっても問題ない
    - デメリット：実装が面倒、メールクライアントによってはURLが正しく動作しない

#### ユーザーIDの重複防止

ユーザーIDが重複してしまうサイトには以下のような不具合がある。

- IDが同一でもパスワードが異なれば別ユーザーとみなすサイト
- DBでユーザーIDに一意制約をつけられないサイト

基本的にはDBの一意制約で対応するのが望ましいが、何らかの理由により対応できない場合、**細心の注意を払って**重複しないよう実装する必要がある。

#### 自動登録への対処

外部から自動操作によって大量の新規ユーザーが作成されることがある。
自動登録のリスクが想定される、または自動登録で被害が出ている場合、CAPTCHAで対策する方法がある。
最も広く使われているCAPTCHAはGoogleが開発しているreCAPTCHAである。

#### パスワード変更

パスワード変更機能に対するセキュリティ上の懸念は以下の通りである。

- 現在のパスワードを確認
    - セッションハイジャックやCSRF対策
- 変更時はメールで通知
    - 第三者が不正にパスワードを変更した場合でも利用者が気付きやすい
- 初期パスワードは初回ログイン時に変更させる

SQLインジェクションの脆弱性があると、以下のような脅威がありうる。

- 再認証を回避してパスワード変更
- 別ユーザー/全ユーザーのパスワードを変更
    - CSRF脆弱性があると不正ログインされる恐れもある

#### メールアドレスの変更

メールアドレスが不正に変更されると、パスワードリセット機能でパスワードを入手される可能性がある。
メールアドレス変更時に行う対策は以下の通りである。

- パスワードを使用した変更前再認証
- 旧メールアドレスに対する変更通知
    - 悪意ある変更の場合、早めに気が付く
    - 既に使えない可能性があるため、受信確認は不要
- 新規メールアドレスに対する受信確認
    - ユーザー登録時と同じようにURL押下orトークン入力を行う

#### パスワードリセット

利用者がパスワードを忘れた場合、何らかの方法でパスワードを回復する仕組みを指す。
パスワードリセットには大きくわけで以下のものがある。

- 管理者向けパスワードリセット
    - 利用者から問い合わせを受けて、管理者が利用者のパスワードをリセットする機能
    - 全てのWebアプリケーションで実装すべき
    - 口頭で直接伝えるのではなく、システムからのメール通知等にすべき
        - ヘルプデスク担当者に伝わるので、悪用が可能
        - 本人を装ったなりすまし対策として有効
    - 発行するパスワードは仮パスワードとすべき
        - 仮パスワード状態ではパスワード変更のみ実行可能とすべき
- 利用者向けパスワードリセット
    - 利用者自らパスワードをリセットする機能
    - 本人確認は登録済みのメールアドレスが一般的
        - スマホアプリの生成する文字列等を使用した二段階認証で本人確認の強化ができる
    - メールは平文で送信されることが多いので、盗聴されるリスクを許容できる場合のみ実装すべき
    - 本人確認後は仮パスワードを送付するか、パスワード変更画面へ遷移する
        - 適切に暗号化されていれば現在のパスワードは送信できない
        - 仮パスワードを送付する場合、本番パスワードとは別に管理し、どちらでもログイン可能とする
            - 仮パスワードでログインしてきた場合はパスワード変更のみ使用可能

#### アカウントの停止

特定アカウントに対しセキュリティ情の問題が生じた場合、当該アカウントを一時的に使用停止とする。
主なセキュリティ上の問題は以下の通りである。

- 利用者本人からの依頼(情報媒体の盗難、心当たりのない変更通知メール)
- 不正アクセスを受けている

アカウントの停止は管理者向けの機能のみとするべきである。
利用者から停止または再開を依頼された場合、本人確認の後実行する。

#### アカウントの削除

通常取り消し不可能な処理であるため、パスワードによる再認証を要求すると良い。

### 認可

認可とは認証された利用者に権限を与えることを指す。

#### 認可不備の典型例

認可制御が失敗している場合、以下のような状態になりうる。

- 情報リソースのURLを知っていると認証なしで閲覧可能
    - 当該ページで認可状態の確認をしていない
- 情報リソースのIDを変更すると権限外の情報が参照できる
    - 当該ページで有効な権限を持っているか確認していない
- hiddenパラメータやCookieに権限を保持している
    - ユーザーが変更可能なパラメータに保持しているだけなので、書き換えられて権限外にアクセスされてしまう

#### 認可制御の要件定義

認可制御を正しく実装するためには、あるべき姿を権限マトリックスとして定義する必要がある。
どのロールのユーザーは何を実行可能なのか、マトリックスとしてまとめることで、開発やテストが正確に実施が可能である。

#### 認可制御の正しい実装

認可制御不備の多くは画面制御のみに頼っているところにある。
正しい認可制御は、以下を確認する。

- 機能に対する実行権限はあるか
- リソースに対する操作権限はあるか

確認に必要なユーザーIDはセッションに格納すること。

### ログ出力

#### ログ出力の目的

以下のような点から、ログはセキュリティ上重要である。

- 攻撃や事故の予兆を把握し、早期に対策を行う
    - ログイン試行やログインエラー回数から外部攻撃の可能性を察知
- 攻撃や事故の事後調査
    - ログがないと攻撃を十分調査できない
- アプリケーションの運用監査

### ログの種類

ログは大きく分けて以下の種類がある。

- Webサーバー(Apacheやnginx)のログ
- アプリケーションのログ
- データベースのログ

セキュリティ上特に注目すべきはアプリケーションのログである。
アプリケーションのログには以下の種類がある。

- エラーログ
    - アプリケーションのエラーを記録するログ
    - エラーの詳細な内容を出力する(表示上は「エラーが発生しました」程度)
    - エラーログは攻撃の検出に役立つ場合がある
        - SQLインジェクション攻撃やディレクトリトラバーサル攻撃を試行中はSQLエラー、ファイルオープンのようなI/Oエラーが発生しやすい
- アクセスログ
    - 情報閲覧や機能利用の記録として、正常/異常問わず残すログ
    - 個人情報漏洩事件や事故への対応に正常系は必要
    - 各種法令やガイドラインで要求されている
- デバッグログ
    - デバッグ用のログ
    - データ量が膨大になりやすく、パフォーマンスに影響が出ることもある
    - 開発環境やテスト環境では取得するが、本番環境では取得するべきではない

#### ログ出力の要件

ログに記録すべきイベントは以下の通りである。
一般的には認証やアカウント管理系の操作を記録する。

- ログイン/ログアウト(失敗含む)
- アカウントロック
- ユーザー登録
- ユーザー削除
- パスワード変更
- 重要情報の参照、操作

ログに記録すべき出力項目は以下の通りである。
基本的に4W1Hに従って記録を行う。
監査等で複数のログを串刺しで処理することが多いため、出力フォーマットを統一しておくと便利である。

- アクセス日時
- IPアドレス
- ログインしているユーザーID
- アクセス対象(URL、ページ番号等)
- 操作内容
- 操作対象
- 操作結果(成功/失敗、対象の件数)

ログは改竄や削除が行われるとその目的を達成できないため、不正アクセスが起こらないように保護する必要がある。
ログを保存するサーバーはWebサーバー/DBサーバーとは別、かつサイト管理者とは別の管理者を割り当てることが望ましい。

ログファイルには以下の情報を含めてはならない。

- パスワード
- クレジットカード情報

Webサイトの特性に応じて、ログの保存期間を運用ルールとして定める必要がある。(期限あり/なし含めて検討する)
定期的にログファイルを長期保管に適した別メディアに記録するなどの工夫も必要である。

ログを組み合わせて調査を行う際、各種ログを付き合わせられるよう時刻を同期させる必要がある。
NTPを用いてサーバーの時刻合わせをすると良い。

#### ログ出力の実装

ログ特有の要求を考慮して設計されたライブラリを使用すると、以下のようなメリットがある。

- ログの目的/出力先が抽象化されていて設定で切り替えが可能
- ログのフォーマットを設定可能
- ソースを書き換えることなくログレベルの変更が可能
